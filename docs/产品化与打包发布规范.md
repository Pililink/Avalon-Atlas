# Avalon Atlas 产品化与打包发布规范

## 当前状态分析

### ✅ 已实现的部分

1. **基础打包配置**
   - PyInstaller 配置文件 (`AvalonAtlas.spec`)
   - 自动化打包脚本 (`build.py`)
   - 依赖管理 (`pyproject.toml`)

2. **项目结构**
   - 模块化代码架构
   - 静态资源管理 (`static/` 目录)
   - 配置文件自动生成机制

3. **文档**
   - README.md 基础说明
   - docs/plan/ 详细设计文档
   - CLAUDE.md 开发指南

### ❌ 缺失的产品化要素

1. **版本管理**
   - ❌ 缺少语义化版本号系统
   - ❌ 缺少版本变更日志 (CHANGELOG.md)
   - ❌ 缺少 Git 版本标签
   - ❌ pyproject.toml 中版本号为占位符 (0.1.0)

2. **应用标识**
   - ❌ 缺少应用图标 (.ico 文件)
   - ❌ 缺少应用元数据（版权、公司信息）
   - ❌ PyInstaller 配置未设置图标和版本信息
   - ❌ 打包输出为控制台模式 (`console=True`)

3. **许可证和法律**
   - ❌ 缺少 LICENSE 文件
   - ❌ 缺少第三方依赖许可声明
   - ❌ 缺少数据来源归属说明文件

4. **分发和部署**
   - ❌ 缺少安装程序 (Installer)
   - ❌ 缺少便携版打包脚本
   - ❌ 缺少自动更新机制
   - ❌ 缺少发布自动化流程 (GitHub Actions/CI)

5. **用户体验**
   - ❌ 缺少首次运行向导
   - ❌ 缺少错误报告机制
   - ❌ 缺少用户配置备份/恢复
   - ❌ 缺少卸载清理脚本

6. **质量保证**
   - ❌ 缺少单元测试
   - ❌ 缺少集成测试
   - ❌ 缺少打包产物验证脚本
   - ❌ 缺少性能基准测试

---

## 产品化改进方案

### 1. 版本管理规范

#### 1.1 采用语义化版本号 (Semantic Versioning)

**格式**: `MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]`

```python
# atlas/version.py
__version__ = "1.0.0"
__version_info__ = (1, 0, 0)

# 版本号规则:
# MAJOR: 不兼容的 API 变更
# MINOR: 向后兼容的功能新增
# PATCH: 向后兼容的问题修复
# 示例: 1.2.3-beta.1+20250120
```

#### 1.2 创建 CHANGELOG.md

```markdown
# Changelog

All notable changes to Avalon Atlas will be documented in this file.

## [Unreleased]

## [1.0.0] - 2025-01-20
### Added
- 子序列模糊搜索功能
- 热键 OCR 识别
- 地图详情预览
- 支持 RapidOCR 和 Tesseract 双引擎

### Fixed
- OCR 数字误识别问题
- 多屏幕截图越界

### Changed
- 优化搜索算法性能 (LRU 缓存)
```

#### 1.3 Git 版本标签自动化

```bash
# 发布脚本示例
#!/bin/bash
VERSION=$(python -c "from atlas.version import __version__; print(__version__)")
git tag -a "v$VERSION" -m "Release v$VERSION"
git push origin "v$VERSION"
```

### 2. 应用标识完善

#### 2.1 图标设计要求

**文件规格**:
- `icon.ico`: 包含 16x16, 32x32, 48x48, 256x256 尺寸
- `icon.png`: 1024x1024 高清版本 (用于商店/网站)
- `icon.icns`: macOS 图标 (如需跨平台)

**设计建议**:
- 使用阿瓦隆主题色（蓝/金）
- 包含地图或指南针元素
- 简洁可识别，适配小尺寸显示

#### 2.2 更新 PyInstaller 配置

```python
# AvalonAtlas.spec
exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,
    name='AvalonAtlas',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    console=False,  # ❗改为窗口模式
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon='assets/icon.ico',  # ❗添加图标
    version='version_info.txt',  # ❗添加版本信息
)
```

#### 2.3 Windows 版本信息文件

```python
# version_info.txt (由脚本自动生成)
VSVersionInfo(
  ffi=FixedFileInfo(
    filevers=(1, 0, 0, 0),
    prodvers=(1, 0, 0, 0),
    mask=0x3f,
    flags=0x0,
    OS=0x40004,
    fileType=0x1,
    subtype=0x0,
    date=(0, 0)
  ),
  kids=[
    StringFileInfo([
      StringTable(
        u'040904B0',
        [StringStruct(u'CompanyName', u'Avalon Tools'),
         StringStruct(u'FileDescription', u'Avalon Online Atlas'),
         StringStruct(u'FileVersion', u'1.0.0'),
         StringStruct(u'InternalName', u'AvalonAtlas'),
         StringStruct(u'LegalCopyright', u'Copyright © 2025'),
         StringStruct(u'OriginalFilename', u'AvalonAtlas.exe'),
         StringStruct(u'ProductName', u'Avalon Atlas'),
         StringStruct(u'ProductVersion', u'1.0.0')])
      ]),
    VarFileInfo([VarStruct(u'Translation', [1033, 1200])])
  ]
)
```

### 3. 许可证和法律合规

#### 3.1 选择开源许可证

**推荐选项**:
- **MIT License**: 宽松，允许商业使用
- **GPL-3.0**: 强制开源衍生作品
- **Apache-2.0**: 专利授权保护

```text
# LICENSE
MIT License

Copyright (c) 2025 [Your Name/Organization]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software")...
```

#### 3.2 第三方依赖许可声明

```markdown
# THIRD_PARTY_LICENSES.md

## 依赖库许可证

本项目使用以下开源库:

| 库名 | 版本 | 许可证 | 用途 |
|------|------|--------|------|
| PySide6 | 6.7.0+ | LGPL-3.0 | GUI 框架 |
| RapidOCR | 1.3.19+ | Apache-2.0 | OCR 引擎 |
| PyInstaller | 6.16.0+ | GPL-2.0 | 打包工具 |

完整许可证文本见 `licenses/` 目录。
```

#### 3.3 数据归属

```markdown
# ATTRIBUTION.md

## 数据来源

地图数据来源于 [ava-maps](https://github.com/lucioreyli/ava-maps)
授权协议: [查看原仓库许可证]

如需更新数据，请参考 `tools/generate_maps_json.py`
```

### 4. 打包和分发流程

#### 4.1 增强的打包脚本

```python
# build.py (改进版)
from __future__ import annotations

import subprocess
import sys
import shutil
from pathlib import Path
import os

def get_version() -> str:
    """从 version.py 读取版本号"""
    version_file = Path(__file__).parent / "atlas" / "version.py"
    namespace = {}
    exec(version_file.read_text(encoding="utf-8"), namespace)
    return namespace["__version__"]

def generate_version_file(version: str) -> Path:
    """生成 Windows 版本信息文件"""
    # ... (生成 version_info.txt 的代码)
    pass

def clean_build() -> None:
    """清理旧的构建产物"""
    for path in ["build", "dist"]:
        if Path(path).exists():
            shutil.rmtree(path)
    print("✓ 清理完成")

def build_executable(version: str) -> int:
    """构建可执行文件"""
    project_root = Path(__file__).parent

    # 生成版本信息
    version_file = generate_version_file(version)

    cmd = [
        sys.executable,
        "-m",
        "PyInstaller",
        "--noconfirm",
        "--clean",
        "--name", "AvalonAtlas",
        "--onedir",
        "--noconsole",  # 窗口模式
        "--icon", "assets/icon.ico",
        "--version-file", str(version_file),
        "--add-data", f"static{os.pathsep}static",
        "--collect-all", "rapidocr_onnxruntime",
        "main.py",
    ]

    process = subprocess.run(cmd, cwd=project_root)
    return process.returncode

def create_portable_package(version: str) -> None:
    """创建便携版压缩包"""
    dist_dir = Path("dist/AvalonAtlas")
    output_zip = Path(f"dist/AvalonAtlas-v{version}-portable.zip")

    shutil.make_archive(
        str(output_zip.with_suffix("")),
        "zip",
        str(dist_dir)
    )
    print(f"✓ 便携版已创建: {output_zip}")

def verify_build() -> bool:
    """验证构建产物"""
    exe_path = Path("dist/AvalonAtlas/AvalonAtlas.exe")
    required_files = [
        "dist/AvalonAtlas/static/data/maps.json",
        "dist/AvalonAtlas/static/maps",
    ]

    if not exe_path.exists():
        print("✗ 可执行文件未找到")
        return False

    for file in required_files:
        if not Path(file).exists():
            print(f"✗ 缺失文件: {file}")
            return False

    print("✓ 构建验证通过")
    return True

def main() -> int:
    version = get_version()
    print(f"📦 开始构建 Avalon Atlas v{version}")

    # 1. 清理
    clean_build()

    # 2. 构建
    ret = build_executable(version)
    if ret != 0:
        print("✗ 构建失败")
        return ret

    # 3. 验证
    if not verify_build():
        return 1

    # 4. 打包
    create_portable_package(version)

    print(f"✅ 构建完成! 输出目录: dist/")
    return 0

if __name__ == "__main__":
    raise SystemExit(main())
```

#### 4.2 安装程序制作

**选项 1: Inno Setup (Windows)**

```iss
; setup.iss
#define MyAppName "Avalon Atlas"
#define MyAppVersion "1.0.0"
#define MyAppPublisher "Avalon Tools"
#define MyAppURL "https://github.com/yourname/atlas"
#define MyAppExeName "AvalonAtlas.exe"

[Setup]
AppId={{YOUR-GUID-HERE}}
AppName={#MyAppName}
AppVersion={#MyAppVersion}
AppPublisher={#MyAppPublisher}
AppPublisherURL={#MyAppURL}
DefaultDirName={autopf}\{#MyAppName}
DefaultGroupName={#MyAppName}
OutputDir=dist\installer
OutputBaseFilename=AvalonAtlas-v{#MyAppVersion}-setup
Compression=lzma
SolidCompression=yes
WizardStyle=modern
SetupIconFile=assets\icon.ico

[Languages]
Name: "chinesesimplified"; MessagesFile: "compiler:Languages\ChineseSimplified.isl"
Name: "english"; MessagesFile: "compiler:Default.isl"

[Tasks]
Name: "desktopicon"; Description: "创建桌面快捷方式"; GroupDescription: "附加任务:"

[Files]
Source: "dist\AvalonAtlas\*"; DestDir: "{app}"; Flags: ignoreversion recursesubdirs

[Icons]
Name: "{group}\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"
Name: "{group}\卸载 {#MyAppName}"; Filename: "{uninstallexe}"
Name: "{autodesktop}\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"; Tasks: desktopicon

[Run]
Filename: "{app}\{#MyAppExeName}"; Description: "运行 {#MyAppName}"; Flags: nowait postinstall skipifsilent
```

**选项 2: NSIS (跨平台)**

```nsis
; installer.nsi
!define PRODUCT_NAME "Avalon Atlas"
!define PRODUCT_VERSION "1.0.0"
!define PRODUCT_PUBLISHER "Avalon Tools"

OutFile "dist\AvalonAtlas-v${PRODUCT_VERSION}-setup.exe"
InstallDir "$PROGRAMFILES\${PRODUCT_NAME}"

Section "主程序" SEC01
  SetOutPath "$INSTDIR"
  File /r "dist\AvalonAtlas\*.*"
  CreateShortCut "$DESKTOP\Avalon Atlas.lnk" "$INSTDIR\AvalonAtlas.exe"
SectionEnd

Section "Uninstall"
  Delete "$DESKTOP\Avalon Atlas.lnk"
  RMDir /r "$INSTDIR"
SectionEnd
```

#### 4.3 GitHub Actions 自动发布

```yaml
# .github/workflows/release.yml
name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  build:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4

      - name: 设置 Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: 安装依赖
        run: |
          pip install -r requirements.txt
          pip install pyinstaller

      - name: 构建应用
        run: python build.py

      - name: 创建发布
        uses: softprops/action-gh-release@v1
        with:
          files: |
            dist/*.zip
            dist/installer/*.exe
          body_path: RELEASE_NOTES.md
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

### 5. 用户体验优化

#### 5.1 首次运行向导

```python
# atlas/ui/first_run_wizard.py
class FirstRunWizard(QtWidgets.QWizard):
    """首次运行配置向导"""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("欢迎使用 Avalon Atlas")

        # 页面1: 欢迎
        self.addPage(self._create_welcome_page())

        # 页面2: OCR 引擎选择
        self.addPage(self._create_ocr_page())

        # 页面3: 热键设置
        self.addPage(self._create_hotkey_page())

        # 页面4: 完成
        self.addPage(self._create_finish_page())

    def _create_welcome_page(self):
        page = QtWidgets.QWizardPage()
        page.setTitle("欢迎")
        layout = QtWidgets.QVBoxLayout()
        layout.addWidget(QtWidgets.QLabel(
            "欢迎使用 Avalon Atlas!\n\n"
            "这是一个阿瓦隆地图查询工具。\n"
            "让我们快速配置一些选项。"
        ))
        page.setLayout(layout)
        return page
```

#### 5.2 错误报告机制

```python
# atlas/crash_reporter.py
import sys
import traceback
from pathlib import Path
from datetime import datetime

def setup_exception_handler():
    """设置全局异常处理"""

    def exception_hook(exc_type, exc_value, exc_traceback):
        # 记录到日志
        logger = get_logger(__name__)
        logger.critical(
            "未捕获的异常",
            exc_info=(exc_type, exc_value, exc_traceback)
        )

        # 保存崩溃报告
        crash_dir = Path("crashes")
        crash_dir.mkdir(exist_ok=True)

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        crash_file = crash_dir / f"crash_{timestamp}.txt"

        with crash_file.open("w", encoding="utf-8") as f:
            f.write(f"Avalon Atlas Crash Report\n")
            f.write(f"Time: {datetime.now()}\n")
            f.write(f"Version: {__version__}\n\n")
            traceback.print_exception(
                exc_type, exc_value, exc_traceback,
                file=f
            )

        # 显示用户友好的错误对话框
        show_crash_dialog(crash_file)

    sys.excepthook = exception_hook
```

#### 5.3 配置备份/恢复

```python
# atlas/config_manager.py
class ConfigManager:
    """配置管理器"""

    def backup_config(self) -> Path:
        """备份当前配置"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_file = self.backup_dir / f"config_{timestamp}.json"
        shutil.copy(self.config_file, backup_file)
        return backup_file

    def restore_config(self, backup_file: Path) -> None:
        """从备份恢复配置"""
        shutil.copy(backup_file, self.config_file)

    def reset_to_default(self) -> None:
        """重置为默认配置"""
        default_config = AppConfig()
        save_config(default_config)
```

### 6. 质量保证体系

#### 6.1 单元测试框架

```python
# tests/test_fuzzy_match.py
import pytest
from atlas.services.fuzzy_match import subsequence_match

class TestSubsequenceMatch:
    def test_exact_match(self):
        result = subsequence_match("test", "test")
        assert result is not None
        assert result.positions == [0, 1, 2, 3]

    def test_subsequence_match(self):
        result = subsequence_match("abc", "a-b-c")
        assert result is not None
        assert len(result.positions) == 3

    def test_no_match(self):
        result = subsequence_match("xyz", "abc")
        assert result is None
```

#### 6.2 集成测试

```python
# tests/test_integration.py
def test_search_workflow():
    """测试完整搜索流程"""
    repository = MapRepository("static/data/maps.json")
    repository.load()

    service = MapSearchService(repository)
    service.refresh()

    results = service.search("casos")
    assert len(results) > 0
    assert "casos" in results[0].record.name.lower()
```

#### 6.3 打包验证脚本

```python
# scripts/verify_build.py
def verify_executable():
    """验证可执行文件"""
    exe_path = Path("dist/AvalonAtlas/AvalonAtlas.exe")

    # 检查文件存在
    assert exe_path.exists(), "可执行文件不存在"

    # 检查文件大小 (应该 > 50MB)
    size_mb = exe_path.stat().st_size / 1024 / 1024
    assert size_mb > 50, f"可执行文件过小: {size_mb}MB"

    # 检查静态资源
    assert (exe_path.parent / "static/data/maps.json").exists()
    assert (exe_path.parent / "static/maps").is_dir()

    print("✓ 构建验证通过")

if __name__ == "__main__":
    verify_executable()
```

---

## 发布检查清单

### 发布前检查

- [ ] 更新版本号 (`atlas/version.py`, `pyproject.toml`)
- [ ] 更新 CHANGELOG.md
- [ ] 运行所有测试 (`pytest`)
- [ ] 本地构建测试 (`python build.py`)
- [ ] 验证构建产物 (`python scripts/verify_build.py`)
- [ ] 检查图标和版本信息是否正确
- [ ] 在干净环境测试安装包
- [ ] 更新 README.md (下载链接、版本号)
- [ ] 准备发布说明 (RELEASE_NOTES.md)

### 发布流程

1. 提交所有变更: `git commit -am "Release v1.0.0"`
2. 创建版本标签: `git tag -a v1.0.0 -m "Release v1.0.0"`
3. 推送到远程: `git push && git push --tags`
4. 等待 GitHub Actions 自动构建
5. 编辑 GitHub Release 页面，添加发布说明
6. 通知用户更新

### 发布后检查

- [ ] 验证下载链接可用
- [ ] 检查 GitHub Release 页面显示正常
- [ ] 在不同系统测试下载的安装包
- [ ] 监控用户反馈和问题报告
- [ ] 更新文档网站 (如有)

---

## 推荐的工具链

### 开发工具
- **uv**: Python 包管理器 (已使用)
- **ruff**: 代码格式化和 Linting
- **mypy**: 类型检查
- **pytest**: 测试框架

### 打包工具
- **PyInstaller**: 可执行文件打包 (已使用)
- **Inno Setup**: Windows 安装程序
- **DMG Canvas**: macOS 磁盘映像 (如需跨平台)

### CI/CD
- **GitHub Actions**: 自动化构建和发布
- **dependabot**: 依赖更新监控

### 监控和分析
- **Sentry**: 错误追踪 (可选)
- **Google Analytics**: 使用统计 (可选)

---

## 总结

当前项目已具备基础打包能力,但需要补充以下关键要素才能达到产品化标准:

### 优先级 P0 (必须)
1. 添加应用图标
2. 修改为窗口模式 (`console=False`)
3. 添加版本管理系统
4. 创建 LICENSE 文件
5. 完善 README.md (安装、使用说明)

### 优先级 P1 (重要)
6. 制作 Windows 安装程序
7. 添加 CHANGELOG.md
8. 配置 GitHub Actions 自动发布
9. 添加基础单元测试
10. 创建构建验证脚本

### 优先级 P2 (建议)
11. 首次运行向导
12. 错误报告机制
13. 配置备份/恢复
14. 性能基准测试
15. 自动更新功能

按照此规范逐步完善,即可将项目从"可运行代码"提升到"可发布产品"的水平。
